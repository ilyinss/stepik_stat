# 1.2 Variables

1.  Создайте переменную my_number и сохраните в нее число 42. Создайте переменную my_logical_var и сохраните в нее логическое значение TRUE.

```{r}
my_number <- 42
my_logical_var <- TRUE
```

2.  В уже созданной переменной var_1, в хранится целое число. Создайте новую переменную var_2, которая равняется var_1 умноженная на 10.

```{r}
var_2 <- var_1 * 10
```

3.  В уже созданных переменных number_1, number_2 и number_3, сохранены целые числа. Проверьте, действительно ли сумма первых двух чисел строго больше, чем третье число. Результат сравнения (TRUE или FALSE) сохраните в новую переменную с именем result.

```{r}
result <- (number_1+number_2)>number_3
```

4.  Создайте переменную the_best_vector, в которой хранятся числа от 1 до 5000 и затем числа от 7000 до 10000.

```{r}
the_best_vector <- c(1:5000,7000:10000)
```

5.  В уже созданной переменной my_numbers сохранен вектор из 20 целых чисел. Ваша задача создать новую переменную my_numbers_2, в которой будет сохранен 2, 5, 7, 9, 12, 16 и 20 элемент вектора my_numbers.

```{r}
my_numbers_2 <- my_numbers[c(2, 5, 7, 9, 12, 16, 20)]
```

6.  В уже созданной переменной my_vector хранится вектор из 20 целых чисел. Найдите сумму всех элементов вектора , которые больше 10. Сохраните сумму в переменную my_sum.

```{r}
my_sum <- sum(my_vector[my_vector > 10])
```

7.  В векторе my_vector отберите только те наблюдения, которые отклоняются от среднего меньше чем на одно стандартное отклонение. Сохраните эти наблюдения в новую переменную my_vector_2. При этом исходный вектор my_vector оставьте без изменений.

```{r}
my_vector <- c(21,18,21,19,25,20,17,17,18,22,17,18,18,19,19,27,21,20,24,17,15,
               24,24,29,19,14,21,17,19,18,18,20,21,21,19,19,17,21,13,17,13,23,
               15,23,24,16,17,25,24,22)
my_vector_2 <- my_vector[my_vector > mean(my_vector) - sd(my_vector) & my_vector < mean(my_vector) + sd(my_vector)]
my_vector_2
```

# 1.3 Dataframe

1.  В этой задаче поработаем со встроенными данными mtcars. В датафрэйме mtcars создайте новую колонку (переменную) под названием even_gear, в которой будут единицы, если значение переменной (gear) четное, и нули если количество нечетное.

```{r}

# 3 vars:
# mtcars$even_gear <- abs(1 - (mtcars$gear %% 2))
# mtcars$even_gear <- ifelse(mtcars$gear %% 2 == 0, 1, 0)
mtcars$even_gear <- (mtcars$gear+1) %% 2
mtcars$even_gear
```

2.  Продолжим нашу работу с данными mtcars. Теперь ваша задача создать переменную - вектор mpg_4 и сохранить в нее значения расхода топлива (mpg) для машин с четырьмя цилиндрами (cyl)

```{r}
mpg_4 <- mtcars$mpg[mtcars$cyl==4]
```

3.  Ваша задача создать новый dataframe под названием mini_mtcars, в котором будут сохранены только третья, седьмая, десятая, двенадцатая и последняя строчка датафрейма mtcars.

```{r}
mini_mtcars <- mtcars[c(3, 7, 10,12,nrow(mtcars)),]
```

# 1.4 Syntax

1.  Создайте новую числовую переменную new_var в данных mtcars, которая содержит единицы в строчках, если в машине не меньше четырёх карбюраторов (переменная "carb") или больше шести цилиндров (переменная "cyl"). В строчках, в которых условие не выполняется, должны стоять нули.

```{r}
mtcars$new_var <- ifelse(mtcars$carb >= 4 | mtcars$cyl > 6, 1, 0)
```

2.  В уже существующей переменной my_vector сохранен вектор из 50 чисел.

Решите задачу используя конструкцию:

    if () {
    } else {
    } 

Если среднее значение вектора my_vector больше 20, в переменную result сохраните "My mean is great", если среднее значение my_vector меньше или равно 20 то в переменную result сохраните строку "My mean is not so great".

```{r}
result <- ifelse (mean(my_vector)>20, "My mean is great", "My mean is not so great")
```

3. В этой задаче от вас потребуется узнать некоторую информацию о типах данных в R самостоятельно! Встроенные в R данные AirPassengers - это новый для нас формат данных типа Time-Series. Изучите структуру этих данных, прежде чем начать решение задачи! Например напишите команды:

  ?AirPassengers # справка о данных
  str(AirPassengers) # структура данных

В встроенных в R данных AirPassengers хранится 144 значения (количество пассажиров в месяц) с 1949 по 1960 год. Данные Time-Series очень похожи на вектор по своей структуре, например мы можем обратиться к любому из 144 элементов используя уже знакомую нам индексацию AirPassengers[1] или AirPassengers[56].

Можно вообще перевести исходные данные в вектор при помощи команды as.vector(AirPassengers) и продолжить с ними работу как с вектором.

И так ваша задача создать переменную good_months и сохранить в нее число пассажиров только в тех месяцах, в которых это число больше, чем показатель в предыдущем месяце.  

Важный момент! В R оператор : для создания последовательности имеет приоритет над арифметическими действиями. Таким образом, если у вас есть переменная i, равная 10, и вы хотите создать вектор от 1 до i - 1, воспользуйтесь скобками, чтобы указать последовательность действий.
```{r}
good_months <- AirPassengers[-1][AirPassengers[-1] > AirPassengers[-144]]
```

4. Задачка для супер героев, повышенной сложности!

Для встроенных в R данных AirPassengers рассчитайте скользящее среднее с интервалом сглаживания равным 10. Напечатайте получившийся результат (первым значением в выводе должно быть среднее для элементов 1:10, во втором значении - среднее для элементов 2:11 и т.д., в последнем  - среднее для элементов 135 :144)
Все полученные значения средних сохраните в переменную moving_average.

Важный момент! В R оператор : для создания последовательности имеет приоритет над арифметическими действиями. Таким образом, если у вас есть переменная i, равная 10, и вы хотите создать вектор от 1 до i - 1, воспользуйтесь скобками, чтобы указать последовательность действий.
  i <- 10
  1 : i - 1 # так мы создадим последовательность от 1 до 10, а потом вычтем единицу из каждого элемента
  [1] 0 1 2 3 4 5 6 7 8 9

  1 : (i - 1) # а вот так мы создадим последовательность от 1 до i - 1, то есть от 1 до 9. 
  [1] 1 2 3 4 5 6 7 8 9

Если вам потребуется создать вектор moving_average заранее, то есть несколько способов сделать это:
1. самый простой, но не очень правильный вариант - создать пустой вектор
moving_average <- c()

2. можно сразу создать вектор определенной длины и определенного типа:
moving_average <- numeric(135)
Такой вариант является более предпочтительным. Почему? Узнаем во второй части курса!)

А для тем, кто уже выбрал путь воина и не хочет использовать цикл - советую познакомиться с функцией cumsum. Подсказка: если у нас есть два вектора одинаковой длинны, то если из одного вектора вычесть второй вектор, мы найдем разность для первых элементов векторов, затем для вторых и т.д.

```{r}
# vars

# 1

moving_average <- numeric(135)
for(i in 1:135) {
  moving_average[i] <- mean(AirPassengers[c(i:(i+9))])
}

# 2 - R style

n <- 10    
d <- AirPassengers    
cx <- c(0, cumsum(d))    
moving_average <- (cx[(n + 1):length(cx)] - cx[1:(length(cx) - n)]) / n
```

# 1.5 Described statistics

1. Вновь вернемся к данным mtcars. Рассчитайте среднее значение времени разгона (qsec) для автомобилей, число цилиндров (cyl) у которых не равняется 3 и показатель количества миль на галлон топлива (mpg) больше 20.
Получившийся результат (среднее значение) сохраните в переменную result.

```{r}
result <- mean(mtcars$qsec[mtcars$cyl != 3 & mtcars$mpg > 20])
```

2. При помощи функции aggregate рассчитайте стандартное отклонение переменной hp (лошадиные силы) и переменной disp (вместимости двигателя)  у машин с автоматической и ручной коробкой передач. 

Полученные результаты (результаты выполнения функции aggregate) сохраните в переменную descriptions_stat.

```{r}
descriptions_stat <- aggregate(cbind(hp, disp) ~ am, mtcars, sd)
```




