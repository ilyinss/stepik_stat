# 1. Preprocess

## 1.2 Variables

1.  Создайте переменную my_number и сохраните в нее число 42. Создайте переменную my_logical_var и сохраните в нее логическое значение TRUE.

```{r}
my_number <- 42
my_logical_var <- TRUE
```

2.  В уже созданной переменной var_1, в хранится целое число. Создайте новую переменную var_2, которая равняется var_1 умноженная на 10.

```{r}
var_2 <- var_1 * 10
```

3.  В уже созданных переменных number_1, number_2 и number_3, сохранены целые числа. Проверьте, действительно ли сумма первых двух чисел строго больше, чем третье число. Результат сравнения (TRUE или FALSE) сохраните в новую переменную с именем result.

```{r}
result <- (number_1+number_2)>number_3
```

4.  Создайте переменную the_best_vector, в которой хранятся числа от 1 до 5000 и затем числа от 7000 до 10000.

```{r}
the_best_vector <- c(1:5000,7000:10000)
```

5.  В уже созданной переменной my_numbers сохранен вектор из 20 целых чисел. Ваша задача создать новую переменную my_numbers_2, в которой будет сохранен 2, 5, 7, 9, 12, 16 и 20 элемент вектора my_numbers.

```{r}
my_numbers_2 <- my_numbers[c(2, 5, 7, 9, 12, 16, 20)]
```

6.  В уже созданной переменной my_vector хранится вектор из 20 целых чисел. Найдите сумму всех элементов вектора , которые больше 10. Сохраните сумму в переменную my_sum.

```{r}
my_sum <- sum(my_vector[my_vector > 10])
```

7.  В векторе my_vector отберите только те наблюдения, которые отклоняются от среднего меньше чем на одно стандартное отклонение. Сохраните эти наблюдения в новую переменную my_vector_2. При этом исходный вектор my_vector оставьте без изменений.

```{r}
my_vector <- c(21,18,21,19,25,20,17,17,18,22,17,18,18,19,19,27,21,20,24,17,15,
               24,24,29,19,14,21,17,19,18,18,20,21,21,19,19,17,21,13,17,13,23,
               15,23,24,16,17,25,24,22)
my_vector_2 <- my_vector[my_vector > mean(my_vector) - sd(my_vector) & my_vector < mean(my_vector) + sd(my_vector)]
my_vector_2
```

## 1.3 Dataframe

1.  В этой задаче поработаем со встроенными данными mtcars. В датафрэйме mtcars создайте новую колонку (переменную) под названием even_gear, в которой будут единицы, если значение переменной (gear) четное, и нули если количество нечетное.

```{r}

# 3 vars:
# mtcars$even_gear <- abs(1 - (mtcars$gear %% 2))
# mtcars$even_gear <- ifelse(mtcars$gear %% 2 == 0, 1, 0)
mtcars$even_gear <- (mtcars$gear+1) %% 2
mtcars$even_gear
```

2.  Продолжим нашу работу с данными mtcars. Теперь ваша задача создать переменную - вектор mpg_4 и сохранить в нее значения расхода топлива (mpg) для машин с четырьмя цилиндрами (cyl)

```{r}
mpg_4 <- mtcars$mpg[mtcars$cyl==4]
```

3.  Ваша задача создать новый dataframe под названием mini_mtcars, в котором будут сохранены только третья, седьмая, десятая, двенадцатая и последняя строчка датафрейма mtcars.

```{r}
mini_mtcars <- mtcars[c(3, 7, 10,12,nrow(mtcars)),]
```

## 1.4 Syntax

1.  Создайте новую числовую переменную new_var в данных mtcars, которая содержит единицы в строчках, если в машине не меньше четырёх карбюраторов (переменная "carb") или больше шести цилиндров (переменная "cyl"). В строчках, в которых условие не выполняется, должны стоять нули.

```{r}
mtcars$new_var <- ifelse(mtcars$carb >= 4 | mtcars$cyl > 6, 1, 0)
```

2.  В уже существующей переменной my_vector сохранен вектор из 50 чисел.

Решите задачу используя конструкцию:

    if () {
    } else {
    } 

Если среднее значение вектора my_vector больше 20, в переменную result сохраните "My mean is great", если среднее значение my_vector меньше или равно 20 то в переменную result сохраните строку "My mean is not so great".

```{r}
result <- ifelse (mean(my_vector)>20, "My mean is great", "My mean is not so great")
```

3.  В этой задаче от вас потребуется узнать некоторую информацию о типах данных в R самостоятельно! Встроенные в R данные AirPassengers - это новый для нас формат данных типа Time-Series. Изучите структуру этих данных, прежде чем начать решение задачи! Например напишите команды:

?AirPassengers \# справка о данных str(AirPassengers) \# структура данных

В встроенных в R данных AirPassengers хранится 144 значения (количество пассажиров в месяц) с 1949 по 1960 год. Данные Time-Series очень похожи на вектор по своей структуре, например мы можем обратиться к любому из 144 элементов используя уже знакомую нам индексацию AirPassengers[1] или AirPassengers[56].

Можно вообще перевести исходные данные в вектор при помощи команды as.vector(AirPassengers) и продолжить с ними работу как с вектором.

И так ваша задача создать переменную good_months и сохранить в нее число пассажиров только в тех месяцах, в которых это число больше, чем показатель в предыдущем месяце.

Важный момент! В R оператор : для создания последовательности имеет приоритет над арифметическими действиями. Таким образом, если у вас есть переменная i, равная 10, и вы хотите создать вектор от 1 до i - 1, воспользуйтесь скобками, чтобы указать последовательность действий.

```{r}
good_months <- AirPassengers[-1][AirPassengers[-1] > AirPassengers[-144]]
```

4.  Задачка для супер героев, повышенной сложности!

Для встроенных в R данных AirPassengers рассчитайте скользящее среднее с интервалом сглаживания равным 10. Напечатайте получившийся результат (первым значением в выводе должно быть среднее для элементов 1:10, во втором значении - среднее для элементов 2:11 и т.д., в последнем - среднее для элементов 135 :144) Все полученные значения средних сохраните в переменную moving_average.

Важный момент! В R оператор : для создания последовательности имеет приоритет над арифметическими действиями. Таким образом, если у вас есть переменная i, равная 10, и вы хотите создать вектор от 1 до i - 1, воспользуйтесь скобками, чтобы указать последовательность действий. i \<- 10 1 : i - 1 \# так мы создадим последовательность от 1 до 10, а потом вычтем единицу из каждого элемента [1] 0 1 2 3 4 5 6 7 8 9

1 : (i - 1) \# а вот так мы создадим последовательность от 1 до i - 1, то есть от 1 до 9. [1] 1 2 3 4 5 6 7 8 9

Если вам потребуется создать вектор moving_average заранее, то есть несколько способов сделать это: 1. самый простой, но не очень правильный вариант - создать пустой вектор moving_average \<- c()

2.  можно сразу создать вектор определенной длины и определенного типа: moving_average \<- numeric(135) Такой вариант является более предпочтительным. Почему? Узнаем во второй части курса!)

А для тем, кто уже выбрал путь воина и не хочет использовать цикл - советую познакомиться с функцией cumsum. Подсказка: если у нас есть два вектора одинаковой длинны, то если из одного вектора вычесть второй вектор, мы найдем разность для первых элементов векторов, затем для вторых и т.д.

```{r}
# vars

# 1

moving_average <- numeric(135)
for(i in 1:135) {
  moving_average[i] <- mean(AirPassengers[c(i:(i+9))])
}

# 2 - R style

n <- 10    
d <- AirPassengers    
cx <- c(0, cumsum(d))    
moving_average <- (cx[(n + 1):length(cx)] - cx[1:(length(cx) - n)]) / n
```

## 1.5 Described statistics

1.  Вновь вернемся к данным mtcars. Рассчитайте среднее значение времени разгона (qsec) для автомобилей, число цилиндров (cyl) у которых не равняется 3 и показатель количества миль на галлон топлива (mpg) больше 20. Получившийся результат (среднее значение) сохраните в переменную result.

```{r}
result <- mean(mtcars$qsec[mtcars$cyl != 3 & mtcars$mpg > 20])
```

2.  При помощи функции aggregate рассчитайте стандартное отклонение переменной hp (лошадиные силы) и переменной disp (вместимости двигателя) у машин с автоматической и ручной коробкой передач.

Полученные результаты (результаты выполнения функции aggregate) сохраните в переменную descriptions_stat.

```{r}
descriptions_stat <- aggregate(cbind(hp, disp) ~ am, mtcars, sd)
```

3.  Воспользуемся встроенными данными airquality. В новую переменную сохраните subset исходных данных, оставив наблюдения только для месяцев 7, 8 и 9.

При помощи функции aggregate рассчитайте количество непропущенных наблюдений по переменной Ozone в 7, 8 и 9 месяце. Для определения количества наблюдений используйте функцию length().

Результат выполнения функции aggregate сохраните в переменную result.

Подсказки:

1.  Не забудьте сделать subset, чтобы отобрать наблюдения только по нужным месяцам, вам может пригодиться следующая конструкция:

x \<- 5 x %in% c(3, 4, 5) [1] TRUE

2.  Для подсчета числа непропущенных наблюдений воспользуйтесь записью с помощью формулы, при которой пропущенные значения не учитываются: aggregate(y \~ x + z , data, FUN)

```{r}
# vers

# 1
# df <- subset(airquality, Month%in%c(7,8,9))
# result <- aggregate(Ozone ~ Month,df,length)

# 2
descriptions_stat <- aggregate(cbind(hp,disp) ~ am, mtcars, sd)
```

3.  Примените функцию describeBy к количественным переменным данных airquality, группируя наблюдения по переменной Month. Чему равен коэффициент асимметрии (skew) переменной Wind в восьмом месяце?

```{r}
library(psych)
# v1 
# describeBy(airquality, airquality$Month == 8)[['TRUE']]['Wind','skew']

# v2
describeBy(airquality$Wind, airquality$Month == 8)$'TRUE'['skew']
```

4.  Обратимся к встроенным данным iris. Соотнесите значения стандартного отклонения переменных.

```{r}
describe(iris)['sd']
```

5.  В данных iris расположите по убыванию значения медиан количественных переменных в группе virginica.

```{r}
describeBy(iris, group = iris$Species)$virginica['median']
```

6.  В переменной my_vector сохранен вектор с пропущенными значениями. Вам нужно создать новый вектор fixed_vector, в котором все пропущенные значения вектора my_vector будут заменены на среднее значение по имеющимся наблюдениям.

При этом исходный вектор оставьте без изменений!

Напоминаю, переменная my_vector уже создана, сразу начинайте работать с ней. Перед тем, как сдавать решение, вы можете потренироваться на различных примерах. Ниже небольшой код, который может создать случайный вектор (выборка из нормального распределения) с пропущенными значениями. my_vector \<- rnorm(30) my_vector[sample(1:30, 10)] \<- NA \# на десять случайных позиций поместим NA

```{r}
fixed_vector <- replace(my_vector, is.na(my_vector), mean(my_vector, na.rm = T))
```

## 1.6 Described statistics // Plots

1.  При помощи функции ggplot() или boxplot() постройте график boxplot, используя встроенные в R данные airquality. По оси x отложите номер месяца, по оси y --- значения переменной Ozone.

На графике boxplot отдельными точками отображаются наблюдения, отклоняющиеся от 1 или 3 квартиля больше чем на полтора межквартильных размаха. Сколько таких наблюдений присутствует в сентябре (месяц №9)?

Обратите внимание, что для корректного отображения графика ggplot ожидает факторную переменную по оси x.

```{r}
# v1
# boxplot(Ozone ~ Month, airquality)

# v2
ggplot(airquality, aes(x = Month, y = Ozone, group = Month)) + geom_boxplot()
```

2.  Используем знакомые нам данные mtcars.

Нужно построить scatterplot с помощью ggplot из ggplot2, по оси x которого будет mpg, по оси y - disp, а цветом отобразить переменную (hp).

Полученный график нужно сохранить в переменную plot1. Таким образом в ответе должен быть скрипт:

plot1 \<- ggplot(data, aes())+ geom\_\*\*\*\*()

```{r}
plot1 <- ggplot(mtcars, aes(x = mpg, y = disp, col = hp))+
  geom_point()
```

3.  Укажите, при помощи какого варианта кода мы можем построить следующий график по данным iris: Гистограмма распределения переменной Sepal.Length, в которой цвет заполнения столбцов гистограммы зависит от значения переменной Species.

ans:\
ggplot(iris, aes(Sepal.Length)) + geom_histogram(aes(fill = Species))\
ggplot(iris, aes(Sepal.Length, fill = Species)) + geom_histogram()

4. Студент Ярослав очень любит строить графики в R. Основываясь на данных iris он хочет построить следующий график:

Scatterplot (диаграмма рассеивания), где по оси X будет отложена переменная Sepal.Length,  по оси Y переменная  Sepal.Width. За цвет точек будет отвечать переменная  Species, а за размер точек переменная Petal.Length.

Ярослав написал следующую команду

  ggplot(aes(Sepal.Length, Sepal.Width, col = Species)) +\
  geom_point(iris, size = Petal.Length)

Однако построить желаемый график не удается! Укажите, какие ошибки совершил Ярослав и попробуйте построить данный график самостоятельно.

ans:\
Первым аргументом функции ggplot() должны быть данные iris.\
Переменная, отвечающая за размер точек должна быть указана внутри функции aes()\

```{r}
ggplot(iris, aes(Sepal.Length, Sepal.Width, col = Species))+
  geom_point(aes(size = Petal.Length))
```

# 2. Statistics in R // Part 1

## 2.1 Nominative data analyze 


