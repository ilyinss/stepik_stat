# 1. Advanced preprocessing

## 1.1 Info

Напишите функцию `NA_position`, которая получает на вход два числовых вектора одинаковой длины. Функция должна возвращать `TRUE`, если позиции `NA` в обоих векторах совпадают или пропущенных значений вообще нет, и значение `FALSE`, если позиции `NA` в векторах не совпадают.

```{r}
NA_position <- function(x, y){
  all(is.na(x) == is.na(y))
}
```

## 1.2 Apply function family // part 1

В переменной `my_df` сохранен `dataframe` с произвольным числом количественных переменных. При помощи функции `apply` найдите максимальное значение в каждой строке. Сохраните результат (вектор максимальных значений) в переменную row_max.

```{r}
my_df <- matrix(rnorm(30), nrow = 5)
```

```{r}
row_max <- apply(my_df, MARGIN = 1, FUN = max)
```

В переменной `my_df` сохранен dataframe с произвольным числом количественных переменных. Рассчитайте медиану для всех столбцов с количественными переменными. В переменную `col_median` сохраните вектор полученных значений.

```{r}
col_median <- apply(my_df, MARGIN = 2, FUN = median)
```

## 1.3 Apply function family // part 2

Давайте завершим и слегка модифицируем задачу из предыдущей лекции. Напишите функцию `get_negative_values`, которая получает на вход `dataframe` произвольного размера. Функция должна для каждой переменной в данных проверять, есть ли в ней отрицательные значения. Если в переменной отрицательных значений нет, то эта переменная нас не интересует, для всех переменных, в которых есть отрицательные значения мы сохраним их в виде списка или матрицы, если число элементов будет одинаковым в каждой переменной (смотри пример работы функции).

```{r}
# ?apply
?sapply
```

```{r}
get_negative_values <- function(test_data){	
    test_data[is.na(test_data)] <- 0
    apply(test_data[colSums(test_data < 0) > 0], 2, function(test_data) test_data[test_data < 0])
}

test_data <- as.data.frame(list(V1 = c(-9.7, -10, -10.5, -7.8, -8.9), V2 = c(NA, -10.2, -10.1, -9.3, -12.2), V3 = c(NA, NA, -9.3, -10.9, -9.8)))
get_negative_values(test_data)


test_data <- as.data.frame(list(V1 = c(NA, 0.5, 0.7, 8), V2 = c(-0.3, NA, 2, 1.2), V3 = c(2, -1, -5, -1.2)))
get_negative_values(test_data)
```

Напишите функцию `na_rm` которая заменяет все пропущенные значения в столбцах `dataframe` на соответствующее среднее значение. То есть все `NA` в первом столбце заменяются на среднее значение первого столбца (рассчитанного без учета `NA`). Все `NA` второго столбца заменяются на среднее значение второго столбца и т.д.

Функция `na_rm` на вход получает `dataframe` произвольной размерности, состоящий из количественных переменных. Функция должна возвращать `dataframe` с замененными `NA`. Ни порядок столбцов, ни порядок строк в `dataframe` изменять не нужно.

Вы можете создавать вспомогательные функции для решения этой задачи.

Напоминаю, что для проверки является ли наблюдение `NA` нужно использовать функцию `is.na()`

```{r}
test_data <- as.data.frame(list(V1 = c(NA, NA, NA, NA, 13, 12, 9, 10, 8, 9, 11, 11, 10, 12, 9), V2 = c(NA, 12, 8, NA, 11, 11, 9, 8, 8, 10, 10, 11, 10, 10, 10), V3 = c(NA, 5, NA, 13, 12, 11, 11, 14, 8, 12, 8, 8, 10, 10, 8), V4 = c(10, 10, 10, 10, 13, 10, 11, 7, 12, 10, 7, 10, 13, 10, 9)))

na_to_mean  <- function(v){    
		v[is.na(v)]  <- mean(v , na.rm = T)    
		return(v)}

na_rm  <- function(x){
	result  <- as.data.frame(apply(x, 2, na_to_mean))
	}

na_rm(test_data)
```

## 1.4 Apply function family // part 3

Напишите функцию `positive_sum`, которая получает на вход `dataframe` с произвольным количеством числовых переменных. Основная задача функции - найти сумму положительных значений в каждой переменной и сохранить их в список. Обратите внимание, если в переменной нет положительных значений, или все значения NA, возвращаем для это переменной 0

```{r}
d <- data.frame(X1 = c(-1, -2, 0), X2 = c(10, 4, NA), X3 = c(-4, NA, NA))

# 1
positive_sum <-  function(test_data){
  res <- lapply(test_data, function(x) x[!is.na(x) & x > 0])
  res <- lapply(res, sum)
  return(res)
}

# 2

# positive_sum <- function(d) {lapply(d, function(x) sum(x[x>0], na.rm = T))}

positive_sum(d)
```

Ой ей, похоже, эта задачка не из простых!

Предположим у нас есть dataframe с двумя переменными name - название гена, expression - уровень экспрессии. Например:

> my_data\
> name expression\
> 1 [p1\@HPS1](mailto:p1@HPS1){.email} 120\
> 2 [p2\@HPS2](mailto:p2@HPS2){.email} 89\
> 3 [p\@GOT1](mailto:p@GOT1){.email} 45

Обратите внимание, что само название гена спрятано внутри строки и указано после символа \@. Напишите функцию my_names, которая получает на вход датафрейм и вектор с именами тех генов, для которых мы хотим отобрать наблюдения уровня экспрессии. Допустим, мы хотим отобрать наблюдения только для генов 'HPS1' и 'GOT1', тогда результат работы функции будет следующий:

> names =c('HPS1', 'GOT1') my_names(my_data, names) name expression 1 [p1\@HPS1](mailto:p1@HPS1){.email} 120 3 [p\@GOT1](mailto:p@GOT1){.email} 45

Таким образом в процессе проверки на вход вашей функции будет подаваться два аргумента:

1.  Датафрейм, c произвольным количеством строк, где имена генов сохранены в переменной names (фактор) в формате `****@name` , а уровень экспрессии в переменной `expression`.

2.  Вектор с именами генов, для которых мы хотим отобрать наблюдения. Гарантируется, что имена указанные в векторе есть в данных.

Функция возвращает датафрейм с наблюдениями только для указанных генов.

Для решения это задачи познакомитесь с функцией `grepl`, которая проверяет, содержится ли одна строчка в другой:

> grepl('HPS1', "[p1\@HPS1](mailto:p1@HPS1){.email}")

```{r}
test_data <- as.data.frame(list(name = c("p4@HPS1", "p7@HPS2", "p4@HPS3", "p7@HPS4", "p7@HPS5", "p9@HPS6", "p11@HPS7", "p10@HPS8", "p15@HPS9"), expression = c(118.84, 90.04, 106.6, 104.99, 93.2, 66.84, 90.02, 108.03, 111.83)))

names = c("HPS5", "HPS6", "HPS9", "HPS2", "HPS3", "HPS7", "HPS4", "HPS8")


my_names <- function(data, names){
  result <- sapply(names, function (x) grepl(x, data$name))
  result <- ifelse(apply(result,1, sum) == 1, T, F)
  return(data[result,])
}

my_names(test_data, names)
```

Напишите функцию `find_outliers`, которая получает на вход `dataframe` с одной количественной переменной и произвольным числом факторных переменных. Факторные переменные разбивают все наши наблюдения на определенное число групп. Например, если мы посмотрим на данные `mtcars` и возьмем в качестве группирующих переменных: `am` - две градации и `cyl` три градации, то получим `6` групп наблюдений на пересечении градаций этих переменных. Рассчитаем, к примеру, средние в каждой из шести групп:    
> aggregate(mpg ~ cyl + am, mtcars, mean)    
> cyl am mpg    
> 1 4 0 22.90000    
> 2 6 0 19.12500    
> 3 8 0 15.05000    
> 4 4 1 28.07500    
> 5 6 1 20.56667    
> 6 8 1 15.40000   

Итак, ваша задача — создать в данных новую числовую переменную `is_outlier`, которая будет принимать значение 1, если наблюдение в этой строке является выбросом в своей группе, и 0, если не является.

Под выбросами будем понимать наблюдения, отклоняющиеся от среднего значения в группе более чем на два стандартных отклонения этой группы. 

Поясню условие на примере данных `ToothGrow`. Сначала переведем группирующие переменные в фактор. Одна из группирующих переменных имеет  две градации, другая три, значит все наши наблюдения разбиваются на шесть групп. Ваша задача проанализировать каждую группу и отметить там выбросы, если они есть. Иными словами, сначала мы берем все наблюдения для которых `supp = VC` и `dose = 0.5`. В этой группе смотрим, есть ли наблюдения, у которых значения `len` отклоняются от среднего в этой группе больше чем на два `sd`. И так повторяем для оставшихся трех групп. В итоге в новой переменной `is_outlier` будет храниться информация - является ли наблюдение выбросом не по всем данным, а только в своей группе.

А также: порядок переменных является случайным, единственная количественная переменная может быть первым столбцом, может последним и т.д.

Данная задачка — не праздное развлечение, чаще всего мы проверяем распределение на нормальность именно в контексте нескольких групп, а не по всей переменной в целом. Наша функция, создав новую переменную, позволит сделать по этой переменной `subset` и убрать все выбросы:

> ToothGrowth  <- find_outliers(ToothGrowth)    
> clear_data <- subset(ToothGrowth, is_outlier == 0)    


